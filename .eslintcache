[{"/home/nicolas/Documents/Development/gol/src/index.js":"1","/home/nicolas/Documents/Development/gol/src/reportWebVitals.js":"2","/home/nicolas/Documents/Development/gol/src/App.js":"3","/home/nicolas/Documents/Development/gol/src/GOL/GOL.js":"4","/home/nicolas/Documents/Development/gol/src/GOL/sketch.js":"5"},{"size":500,"mtime":1607036396241,"results":"6","hashOfConfig":"7"},{"size":362,"mtime":1607036396241,"results":"8","hashOfConfig":"7"},{"size":156,"mtime":1607036396241,"results":"9","hashOfConfig":"7"},{"size":4690,"mtime":1607036546520,"results":"10","hashOfConfig":"7"},{"size":1773,"mtime":1607034336951,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"gg22zz",{"filePath":"15","messages":"16","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"14"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/nicolas/Documents/Development/gol/src/index.js",[],["24","25"],"/home/nicolas/Documents/Development/gol/src/reportWebVitals.js",[],"/home/nicolas/Documents/Development/gol/src/App.js",[],"/home/nicolas/Documents/Development/gol/src/GOL/GOL.js",["26","27"],"import React, { useEffect, useState, useRef } from 'react'\nimport P5Wrapper from 'react-p5-wrapper';\nimport './style.css';\nimport SketchObject from './sketch';\nimport { Image } from 'image-js';\nimport logo from './image.jpg'\nimport { cloneDeep } from 'lodash';\n\nconst INITIAL_SQUARE_NUMBER_WIDTH = 200;\n\nconst DEV_MODE = false;\n\nconst GOL = () => {\n    const parseRgbArray = (pixelArray, width) => {\n        var newArray = []\n        for (var i = 0; i < pixelArray.length / width; i++) {\n            newArray.push(pixelArray.slice(i*width, (i+1)*width))\n        }\n\n        return newArray;\n    }\n\n    const initGrid = async () => {\n        var loaded = await Image.load(logo);\n        loaded = loaded.resize({width: 60})\n        const maxX = parseInt(INITIAL_SQUARE_NUMBER_WIDTH);\n        const maxY = parseInt(INITIAL_SQUARE_NUMBER_WIDTH*(window.innerHeight/window.innerWidth));\n        var rgbArray = parseRgbArray(loaded.getPixelsArray(), loaded.width);\n        var widthRgbArray = rgbArray.length;\n        var heightRgbArray = rgbArray[0].length;\n        var xStartImage = parseInt((maxX/2) - (widthRgbArray/2))\n        var yStartImage = parseInt((maxY/2) - (heightRgbArray/2))\n\n\n        let newSquareGrid = Array.from(\n            Array(maxX), \n            () => new Array(maxY).fill({\n                living: false,\n                rgb: null\n            })\n        )\n\n        for(var i = 0; i < widthRgbArray; i++) {\n            for(var j = 0; j < heightRgbArray; j++) {\n                // White pixel filtering\n                if((rgbArray[i][j][0] + rgbArray[i][j][1] + rgbArray[i][j][2]) < 700)\n                    newSquareGrid[xStartImage + i][yStartImage + j] = {\n                        living: true,\n                        rgb: rgbArray[i][j]\n                    }\n            }\n        }\n\n        return newSquareGrid;\n    }\n\n\n    const handleDimensionChange = p => {\n        setState({\n            ...state, \n            squareGrid: initGrid(),\n            dimensions: { \n                w: window.innerWidth,\n                h: window.innerHeight\n            },\n            squareDimensions: {\n                w: parseInt(INITIAL_SQUARE_NUMBER_WIDTH),\n                h: parseInt(INITIAL_SQUARE_NUMBER_WIDTH*(window.innerHeight/window.innerWidth))\n            }\n        })\n    }\n\n    const countNeighbours = (x, y, grid) => {\n        var nbNeighbours = 0;\n        for(let i = -1; i <= 1; i++) {\n            for(let j = -1; j <= 1; j++) {\n                if(i !== 0 || j !== 0) {\n                    if((x + i > 0) && (y + j > 0) && (x + i < grid.length) && (y + j < grid[0].length)) {\n                        nbNeighbours += (grid[x + i][y + j].living ? 1 : 0);\n                    }\n                }\n            }\n        }\n\n        return nbNeighbours;\n    }\n\n    const gameRoundHandler = p => {\n        var newSquareGrid = cloneDeep(state.squareGrid);\n\n        for (let x = 0; x < newSquareGrid.length; x++) {\n            for (let y = 0; y < newSquareGrid[0].length; y++) {\n                var nbNeighbours = countNeighbours(x, y, [...state.squareGrid]);\n                if(newSquareGrid[x][y].living) {\n                    if (nbNeighbours !== 2 && nbNeighbours !== 3) newSquareGrid[x][y] = {\n                        ...newSquareGrid[x][y],\n                        living: false,\n                    };\n                }\n                else {\n                    if (nbNeighbours === 3) newSquareGrid[x][y] = {\n                        living: true,\n                    };\n                }\n            }\n        }\n\n        setState({\n            ...state, \n            squareGrid: newSquareGrid\n        })\n    }\n\n    const [state, setState] = useState({\n        dimensions: {\n            w: window.innerWidth,\n            h: window.innerHeight\n        },\n        squareGrid: [],\n        squareSize: INITIAL_SQUARE_NUMBER_WIDTH\n    })\n\n    useEffect(() => {\n        // UNSTABLE (need to handle the removal of squares)\n        window.addEventListener(\"resize\", handleDimensionChange);\n        \n        const interval = setInterval(gameRoundHandler, 400);\n\n        return () => {\n            window.removeEventListener(\"resize\", handleDimensionChange);\n            clearInterval(interval)\n        }\n    })\n\n    useEffect(() => {\n        initGrid().then(grid => {\n            setState({\n                ...state,\n                squareGrid: grid\n            })\n        })\n    }, []);\n  \n    // Note : the component triggers a redraw + prop change whenever the parent component (GOF) is mounted\n    return <P5Wrapper sketch={SketchObject} dimensions={state.dimensions} squareSize={state.squareSize} squareGrid={state.squareGrid} devMode={DEV_MODE}/>\n}\n\nexport default GOL","/home/nicolas/Documents/Development/gol/src/GOL/sketch.js",[],{"ruleId":"28","replacedBy":"29"},{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","severity":1,"message":"33","line":1,"column":38,"nodeType":"34","messageId":"35","endLine":1,"endColumn":44},{"ruleId":"36","severity":1,"message":"37","line":142,"column":8,"nodeType":"38","endLine":142,"endColumn":10,"suggestions":"39"},"no-native-reassign",["40"],"no-negated-in-lhs",["41"],"no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'initGrid' and 'state'. Either include them or remove the dependency array. You can also do a functional update 'setState(s => ...)' if you only need 'state' in the 'setState' call.","ArrayExpression",["42"],"no-global-assign","no-unsafe-negation",{"desc":"43","fix":"44"},"Update the dependencies array to be: [initGrid, state]",{"range":"45","text":"46"},[4399,4401],"[initGrid, state]"]